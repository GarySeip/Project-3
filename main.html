<html>
    <head>
        <title>CSC3210 Project 3</title>
    </head>
    <body>

    <canvas id = "myCanvas" width = window.innerWidth height = window.innerHeight></canvas>

    <script type = "module">

        /**
         * PLEASE NOTE
         * This project requires that it be run on a server to avoid violating CORS policy.
         **/
        import * as THREE from "http://cs.merrimack.edu/~stuetzlec/three.js-master/build/three.module.js";
        import { OrbitControls } from "http://cs.merrimack.edu/~stuetzlec/three.js-master/examples/jsm/controls/OrbitControls.js"
        import { Card } from "./Card.js";
        import { Deck } from "./Deck.js";
    
    // Objects
        // Create the object to represent a triangle
        // a, b, and c are arrays containing the xyz coordinates of the vertices to be used in the triangle.
        // aCol, bCol, and cCol are the colors of the respective points.
        function Plane (length, height) 
        {
            this.length = length;
            this.height = height;

            // The function that actually adds the triangle geometry to the scene
            this.render = function(imagePath) 
            {
                var loader = new THREE.TextureLoader();

                this.geometry = new THREE.PlaneGeometry(this.length, this.height);
                
                this.material = new THREE.MeshPhongMaterial({map: loader.load(imagePath), side: THREE.DoubleSide});
                this.mesh = new THREE.Mesh(this.geometry, this.material);

                scene.add(this.mesh);
            }
        };
    // End Objects
    // Functions

    // End Functions
    // Constants
        // The colors for the puzzle.
        const backgroundColor = [0, 0, 0];
        const baseZoom = 6;
        // 655 and 930 are respectively the width and height of the card images.
        const width = 655 / 200;
        const height = 930 / 200;
        // This will make a full deck of cards look like a square when viewed along the length of the cards.
        const depth = width / 52;
        const woodTable = "./Textures/table.jpg";
        const merriTable = "./Textures/merriTable.jpg";
        const merriTableFelt = "./Textures/merriTable.png";
        const defaultAmbience = new THREE.Color(1, 1, 1);
        const ambientIntensity = 1;
    // End Constants
    // Variables
        var scene;
        var camera;
        var renderer;
        var images = new Array();
        var currImage = 0;
        var prevTime;
        var time;
        var delta;
        var movingLight = new THREE.PointLight();
        var ambientLight = new THREE.AmbientLight(defaultAmbience, ambientIntensity);
        var ambienceOn = true;
    // End Variables

        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera(125, window.innerWidth / window.innerHeight, .1, 3000);
        camera.position.z = baseZoom;
        camera.lookAt(new THREE.Vector3(0.0,0.0,0.0));
        scene.add(camera);

        renderer = new THREE.WebGLRenderer({canvas: myCanvas, antialias: true});
        renderer.setClearColor((new THREE.Color).fromArray(backgroundColor));
        renderer.setSize(window.innerWidth, window.innerHeight);

        var table = new Plane(160, 90);
        table.render(merriTableFelt);
        table.mesh.rotation.x = 3 * Math.PI / 2;
        table.mesh.position.setY(0 - depth / 2);

        var box = new THREE.BoxGeometry();
        var mat = new THREE.MeshPhongMaterial();
        var msh = new THREE.Mesh(box, mat);
        scene.add(msh);

        msh.position.setY(5);

        // Test code
        var deck = new Deck(width, height, depth);
        deck.constructCards();
        deck.cardRenderTest(scene);
        // End test code
        
        scene.add(ambientLight);

        var od = new OrbitControls(camera, renderer.domElement);

        function animate()
        {
            requestAnimationFrame(animate);
            
            time = performance.now();

            if(true /* Render boolean */)
            {
                delta = (time - prevTime) / 1000;


            }

            prevTime = time;
                
            render();
        }

        function render()
        {
            renderer.render(scene, camera);
        }

        // The keyHandler provides functionality for the user to control the camera.
        // This was done for Above and Beyond.
        function keyHandler(e)
        {
            var key = e.key.toLowerCase();
            switch(key)
            {
                // N case advances the game.
                case "n":
                    
                    break;
                // L case toggles ambient light.
                case "l":
                    if(ambienceOn)
                    {
                        ambientLight.intensity = 0;
                        ambienceOn = false;
                    }
                    else
                    {
                        ambientLight.intensity = ambientIntensity;
                        ambienceOn = true;
                    }
                    break;
                // P case toggles moveable point light.
                case "p":

                    break;
                // M case toggles shadows.
                case "m":

                    break;
                // W case increases the light's Z value.
                case "w":

                    break;
                // A case decreases the light's X value.
                case "a":

                    break;
                // S case decreases the light's Z value.
                case "s":

                    break;
                // D case increases the light's X value.
                case "d":

                    break;
            }
        };
        
        document.addEventListener("keydown", keyHandler, false);

        var prevTime = performance.now();
        // Animates the game.
        animate();
    </script>
    </body>    
</html> 