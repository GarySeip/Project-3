<html>
    <head>
        <title>CSC3210 Project 3</title>
        <!-- 
            CSC3210 Project 2
            Authors: Jad Noureddine and Garald Seip

            This file serves as a driver for the project. It imports requires files and sets up
            the scene, the camera, and the animation loop. It also sets up several of the basic components such as
            the table and lighting.

            For our above and beyond, we !!!!!!!!!!!!!!!!!!!!!!!!!
                                         !!!!!!!!!!!!!!!!!!!!!!!!!
                                         !!!!!!!!!!!!!!!!!!!!!!!!!
                                         !!!!!!!!!!!!!!!!!!!!!!!!!
                                         !!!!!! UPDATE THIS !!!!!!
                                         !!!!!!!!!!!!!!!!!!!!!!!!!
                                         !!!!!!!!!!!!!!!!!!!!!!!!!
                                         !!!!!!!!!!!!!!!!!!!!!!!!!
                                         !!!!!!!!!!!!!!!!!!!!!!!!!
        -->
    </head>
    <body>

    <canvas id = "myCanvas" width = window.innerWidth height = window.innerHeight></canvas>

    <script type = "module">

        /**
         * PLEASE NOTE
         * This project requires that it be run on a server to avoid violating CORS policy.
         **/
        import * as THREE from "http://cs.merrimack.edu/~stuetzlec/three.js-master/build/three.module.js";
        import { OrbitControls } from "http://cs.merrimack.edu/~stuetzlec/three.js-master/examples/jsm/controls/OrbitControls.js"
        import { Card } from "./Card.js";
        import { Deck } from "./Deck.js";
        import { Player } from "./Player.js";
        import { War } from "./War.js";
        import { AnimationHelper } from "./AnimationHelper.js";
    
    // Objects
        // Create the object to represent a triangle
        // a, b, and c are arrays containing the xyz coordinates of the vertices to be used in the triangle.
        // aCol, bCol, and cCol are the colors of the respective points.
        function Plane (length, height) 
        {
            this.length = length;
            this.height = height;

            // The function that actually adds the triangle geometry to the scene
            this.render = function(imagePath) 
            {
                var loader = new THREE.TextureLoader();

                this.geometry = new THREE.PlaneGeometry(this.length, this.height);
                
                this.material = new THREE.MeshPhongMaterial({map: loader.load(imagePath), side: THREE.DoubleSide});
                this.mesh = new THREE.Mesh(this.geometry, this.material);
                this.mesh.receiveShadow = true;

                scene.add(this.mesh);
            }
        };
    // End Objects
    // Functions
        /**
         * This function toggles every non-ambient light's ability to cast shadows.
         */
        function toggleShadows()
        {
            for(var i = 0; i < lightArray.length; i++)
                lightArray[i].castShadow = !lightArray[i].castShadow;
        }

        /**
         * This function handles progressing every animation in the animationArray.
         */
        function handleAnimations()
        {
            // Progresses every animation every frame.
            for(var i = animationArray.length - 1; i >= 0; i--)
                if(animationArray[i].animate(delta))
                    // If an animation has finished, it is removed from the array.
                    animationArray.splice(i, 1);
            
            if(animationArray.length == 0)
               handleScoreLights();
            
            animRunning = animationArray.length != 0;
        }

        /** 
         * This function adjusts the intensity of the score lights to reflect
         */
        function handleScoreLights()
        {
            
        }

        /**
         * This function sets up the positions and orientations of the score lights.
         */
        function setUpScoreLights()
        {
            player0Light.translateY(movingLightHeight * 2);
            player0Light.castShadow = true;
            player1Light.translateY(movingLightHeight * 2);
            player1Light.castShadow = true;
            player2Light.translateY(movingLightHeight * 2);
            player2Light.castShadow = true;

            scene.add(player0Light.target);
            scene.add(player1Light.target);
            scene.add(player2Light.target);

            var tarPos = players[0].deckPos.clone();
            tarPos.applyAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI / 6);
            player0Light.position.set(tarPos.x, player0Light.position.y, tarPos.z);
            player0Light.target.translateX(tarPos.x);
            player0Light.target.translateZ(tarPos.z);
            
            tarPos.applyAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI * 2 / 3);
            player1Light.position.set(tarPos.x, player1Light.position.y, tarPos.z);
            player1Light.target.translateX(tarPos.x);
            player1Light.target.translateZ(tarPos.z);
            
            tarPos.applyAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI * 2 / 3);
            player2Light.position.set(tarPos.x, player2Light.position.y, tarPos.z);
            player2Light.target.translateX(tarPos.x);
            player2Light.target.translateZ(tarPos.z);
        }
    // End Functions
    // Constants
        // The colors for the puzzle.
        const backgroundColor = [0, 0, 0];
        const baseZoom = 6;
        // 655 and 930 are respectively the width and height of the card images.
        const width = 655 / 200;
        const height = 930 / 200;
        // Dividing by 52 will make a full deck of cards look like a square when viewed along the length of the cards.
        const depth = width / 52;
        // The filepaths for several possible table textures.
        const woodTable = "./Textures/table.jpg";
        const merriTable = "./Textures/merriTable.jpg";
        const merriTableFelt = "./Textures/merriTable.png";
        // ambientInensity is the intensity of the ambient light.
        const ambientIntensity = 1;
        // movingLightIntensity is the intensity of the moving point light.
        const movingLightIntensity = 2;
        const playerLightIntesnity = 5;
        // movingLightHeight is the height of the moving point light.
        const movingLightHeight = 10;
        // movingLightSpeed is the speed at which the moving point light moves.
        const movingLightSpeed = 50;
    // End Constants
    // Variables
        var scene;
        var camera;
        var renderer;
        // prevTime stores the time the last frame was rendered.
        var prevTime;
        // time stores the time the current frame was rendered.
        var time;
        // delta stores the time difference between the current frame and the last frame in seconds.
        var delta;
        var players = [new Player(0), new Player(1), new Player(2)];
        var war = new War(players);
        var animationArray = new Array();
        var deck = new Deck(width, height, depth, animationArray);
        // movingLight is the moving point light.
        var movingLight = new THREE.PointLight(new THREE.Color(1, 0, 1), movingLightIntensity, 0, 2);
        // movingLightOn stores whether the moving point light is on.
        var movingLightOn = true;
        // ambientLight is the ambient light.
        var ambientLight = new THREE.AmbientLight(new THREE.Color(1, 1, 1), ambientIntensity);
        // ambienceOn stores if the ambient light is on.
        var ambienceOn = true;
        // The lights for each player's score.
        var player0Light = new THREE.SpotLight(new THREE.Color(1, 1, 1), playerLightIntesnity, 0, Math.PI / 6);
        var player1Light = new THREE.SpotLight(new THREE.Color(1, 1, 1), playerLightIntesnity, 0, Math.PI / 6);
        var player2Light = new THREE.SpotLight(new THREE.Color(1, 1, 1), playerLightIntesnity, 0, Math.PI / 6);
        // lightArray stores the lights in the scene that cast shadows. 
        var lightArray = [movingLight, player0Light, player1Light, player2Light];
        var animRunning = false;
    // End Variables

        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera(125, window.innerWidth / window.innerHeight, .1, 3000);
        camera.position.z = baseZoom;
        camera.lookAt(new THREE.Vector3(0.0,0.0,0.0));
        scene.add(camera);

        renderer = new THREE.WebGLRenderer({canvas: myCanvas, antialias: true});
        renderer.setClearColor((new THREE.Color).fromArray(backgroundColor));
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;

        // Creates the table and places it correctly.
        var table = new Plane(160, 90);
        table.render(merriTableFelt);
        table.mesh.rotation.x = 3 * Math.PI / 2;
        table.mesh.position.setY(-0.01 - depth / 2);

        // Creates the cards and adds them to the scene in the appropriate place.
        deck.constructCards();
        deck.spawnDeck(scene);

        // Sets up the moving light.
        movingLight.translateY(movingLightHeight);
        movingLight.castShadow = true;

        // Sets up the spotlights.
        setUpScoreLights();
        
        // Adds the lights to the scene.
        scene.add(ambientLight);
        scene.add(movingLight);
        scene.add(player0Light);
        scene.add(player1Light);
        scene.add(player2Light);

        var od = new OrbitControls(camera, renderer.domElement);

        function animate()
        {
            requestAnimationFrame(animate);
            
            // Gets the current time.
            time = performance.now();

            if(true /* Render boolean */)
            {
                // Gets the time difference between the current frame and the last frame in seconds.
                delta = (time - prevTime) / 1000;

                handleAnimations();
            }

            // Outputs the camera's position so that OrbitControls can be used to find a good camera angle.
            // console.log(camera.position.toArray());

            // Updates when the previous frame was rendered.
            prevTime = time;
                
            render();
        }

        function render()
        {
            renderer.render(scene, camera);
        }

        // The keyHandler provides functionality for the user to control the camera.
        // This was done for Above and Beyond.
        function keyHandler(e)
        {
            var key = e.key.toLowerCase();
            switch(key)
            {
                // N case advances the game.
                case "n":
                    if(!animRunning)
                        // war.advanceGameStep();
                        deck.shuffle();
                    break;
                // L case toggles ambient light.
                case "l":
                    if(ambienceOn)
                    {
                        ambientLight.intensity = 0;
                        ambienceOn = false;
                    }
                    else
                    {
                        ambientLight.intensity = ambientIntensity;
                        ambienceOn = true;
                    }
                    break;
                // P case toggles moveable point light.
                case "p":
                    if(movingLightOn)
                    {
                        movingLight.intensity = 0;
                        movingLightOn = false;
                    }
                    else
                    {
                        movingLight.intensity = movingLightIntensity;
                        movingLightOn = true;
                    }
                    break;
                // M case toggles shadows.
                case "m":
                    toggleShadows();
                    break;
                // W case decreases the light's Z value.
                case "w":
                    if(movingLightOn)
                        movingLight.position.add(new THREE.Vector3(0, 0, movingLightSpeed * -delta));
                    break;
                // A case decreases the light's X value.
                case "a":
                    if(movingLightOn)
                        movingLight.position.add(new THREE.Vector3(movingLightSpeed * -delta, 0, 0));
                    break;
                // S case increases the light's Z value.
                case "s":
                    if(movingLightOn)
                        movingLight.position.add(new THREE.Vector3(0, 0, movingLightSpeed * delta));
                    break;
                // D case increases the light's X value.
                case "d":
                    if(movingLightOn)
                        movingLight.position.add(new THREE.Vector3(movingLightSpeed * delta, 0, 0));
                    break;
            }
        };
        
        document.addEventListener("keydown", keyHandler, false);

        // Initializes prevTime.
        var prevTime = performance.now();

        // Animates the game.
        animate();
    </script>
    </body>    
</html> 