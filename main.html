<html>
    <head>
        <title>CSC3210 Project 3</title>
        <!-- 
            CSC3210 Project 2
            Authors: Jad Noureddine and Garald Seip

            This file serves as a driver for the project. It imports requires files and sets up
            the scene, the camera, and the animation loop. It also sets up several of the basic components such as
            the table and lighting.

            For our above and beyond, we !!!!!!!!!!!!!!!!!!!!!!!!!
                                         !!!!!!!!!!!!!!!!!!!!!!!!!
                                         !!!!!!!!!!!!!!!!!!!!!!!!!
                                         !!!!!!!!!!!!!!!!!!!!!!!!!
                                         !!!!!! UPDATE THIS !!!!!!
                                         !!!!!!!!!!!!!!!!!!!!!!!!!
                                         !!!!!!!!!!!!!!!!!!!!!!!!!
                                         !!!!!!!!!!!!!!!!!!!!!!!!!
                                         !!!!!!!!!!!!!!!!!!!!!!!!!
        -->
    </head>
    <body>

    <canvas id = "myCanvas" width = window.innerWidth height = window.innerHeight></canvas>

    <script type = "module">

        /**
         * PLEASE NOTE
         * This project requires that it be run on a server to avoid violating CORS policy.
         **/
        import * as THREE from "http://cs.merrimack.edu/~stuetzlec/three.js-master/build/three.module.js";
        import { OrbitControls } from "http://cs.merrimack.edu/~stuetzlec/three.js-master/examples/jsm/controls/OrbitControls.js"
        import { Card } from "./Card.js";
        import { Deck } from "./Deck.js";
        import { Player } from "./Player.js";
        import { War } from "./War.js";
    
    // Objects
        // Create the object to represent a triangle
        // a, b, and c are arrays containing the xyz coordinates of the vertices to be used in the triangle.
        // aCol, bCol, and cCol are the colors of the respective points.
        function Plane (length, height) 
        {
            this.length = length;
            this.height = height;

            // The function that actually adds the triangle geometry to the scene
            this.render = function(imagePath) 
            {
                var loader = new THREE.TextureLoader();

                this.geometry = new THREE.PlaneGeometry(this.length, this.height);
                
                this.material = new THREE.MeshPhongMaterial({map: loader.load(imagePath), side: THREE.DoubleSide});
                this.mesh = new THREE.Mesh(this.geometry, this.material);
                this.mesh.receiveShadow = true;

                scene.add(this.mesh);
            }
        };
    // End Objects
    // Functions
        /**
         * This function toggles every non-ambient light's ability to cast shadows.
         */
        function toggleShadows()
        {
            for(var i = 0; i < lightArray.length; i++)
                lightArray[i].castShadow = !lightArray[i].castShadow;
        }
    // End Functions
    // Constants
        // The colors for the puzzle.
        const backgroundColor = [0, 0, 0];
        const baseZoom = 6;
        // 655 and 930 are respectively the width and height of the card images.
        const width = 655 / 200;
        const height = 930 / 200;
        // Dividing by 52 will make a full deck of cards look like a square when viewed along the length of the cards.
        const depth = width / 52;
        // The filepaths for several possible table textures.
        const woodTable = "./Textures/table.jpg";
        const merriTable = "./Textures/merriTable.jpg";
        const merriTableFelt = "./Textures/merriTable.png";
        // defautlAmbience is the default color (white) of the ambient light.
        const defaultAmbience = new THREE.Color(1, 1, 1);
        // ambientInensity is the intensity of the ambient light.
        const ambientIntensity = 1;
        // defaultMovingPoint is the default color (purple) of the moving point light.
        const defaultMovingPoint = new THREE.Color(1, 0, 1);
        // movingLightIntensity is the intensity of the moving point light.
        const movingLightIntensity = 2;
        // movingLightHeight is the height of the moving point light.
        const movingLightHeight = 10;
        // movingLightSpeed is the speed at which the moving point light moves.
        const movingLightSpeed = 50;
    // End Constants
    // Variables
        var scene;
        var camera;
        var renderer;
        // prevTime stores the time the last frame was rendered.
        var prevTime;
        // time stores the time the current frame was rendered.
        var time;
        // delta stores the time difference between the current frame and the last frame in seconds.
        var delta;
        // movingLight is the moving point light.
        var movingLight = new THREE.PointLight(defaultMovingPoint, movingLightIntensity, 0, 2);
        // movingLightOn stores whether the moving point light is on.
        var movingLightOn = true;
        // ambientLight is the ambient light.
        var ambientLight = new THREE.AmbientLight(defaultAmbience, ambientIntensity);
        // ambienceOn stores if the ambient light is on.
        var ambienceOn = true;
        // lightArray stores the lights in the scene that cast shadows. More than just movingLight are planned to be
        // added later.
        var lightArray = [movingLight];
        var gameRunning = false;
        var players = [new Player(0), new Player(1), new Player(2)];
        var war = new War(players);
        var deck = new Deck(width, height, depth);
    // End Variables

        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera(125, window.innerWidth / window.innerHeight, .1, 3000);
        camera.position.z = baseZoom;
        camera.lookAt(new THREE.Vector3(0.0,0.0,0.0));
        scene.add(camera);

        renderer = new THREE.WebGLRenderer({canvas: myCanvas, antialias: true});
        renderer.setClearColor((new THREE.Color).fromArray(backgroundColor));
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;

        // Creates the table and places it correctly.
        var table = new Plane(160, 90);
        table.render(merriTableFelt);
        table.mesh.rotation.x = 3 * Math.PI / 2;
        table.mesh.position.setY(0 - depth / 2);

        // Test code
        deck.constructCards();
        deck.cardRenderTest(scene);
        // End test code

        // Sets up the moving light.
        movingLight.translateY(movingLightHeight);
        movingLight.castShadow = true;
        
        // Adds the lights to the scene.
        scene.add(ambientLight);
        scene.add(movingLight);

        var od = new OrbitControls(camera, renderer.domElement);

        function animate()
        {
            requestAnimationFrame(animate);
            
            // Gets the current time.
            time = performance.now();

            if(true /* Render boolean */)
            {
                // Gets the time difference between the current frame and the last frame in seconds.
                delta = (time - prevTime) / 1000;


            }

            // Outputs the camera's position so that OrbitControls can be used to find a good camera angle.
            console.log(camera.position.toArray());

            // Updates when the previous frame was rendered.
            prevTime = time;
                
            render();
        }

        function render()
        {
            renderer.render(scene, camera);
        }

        // The keyHandler provides functionality for the user to control the camera.
        // This was done for Above and Beyond.
        function keyHandler(e)
        {
            var key = e.key.toLowerCase();
            switch(key)
            {
                // N case advances the game.
                case "n":
                    if(gameRunning)
                        war.advanceGameStep();
                    break;
                // L case toggles ambient light.
                case "l":
                    if(ambienceOn)
                    {
                        ambientLight.intensity = 0;
                        ambienceOn = false;
                    }
                    else
                    {
                        ambientLight.intensity = ambientIntensity;
                        ambienceOn = true;
                    }
                    break;
                // P case toggles moveable point light.
                case "p":
                    if(movingLightOn)
                    {
                        movingLight.intensity = 0;
                        movingLightOn = false;
                    }
                    else
                    {
                        movingLight.intensity = movingLightIntensity;
                        movingLightOn = true;
                    }
                    break;
                // M case toggles shadows.
                case "m":
                    toggleShadows();
                    break;
                // W case decreases the light's Z value.
                case "w":
                    if(movingLightOn)
                        movingLight.position.add(new THREE.Vector3(0, 0, movingLightSpeed * -delta));
                    break;
                // A case decreases the light's X value.
                case "a":
                    if(movingLightOn)
                        movingLight.position.add(new THREE.Vector3(movingLightSpeed * -delta, 0, 0));
                    break;
                // S case increases the light's Z value.
                case "s":
                    if(movingLightOn)
                        movingLight.position.add(new THREE.Vector3(0, 0, movingLightSpeed * delta));
                    break;
                // D case increases the light's X value.
                case "d":
                    if(movingLightOn)
                        movingLight.position.add(new THREE.Vector3(movingLightSpeed * delta, 0, 0));
                    break;
            }
        };
        
        document.addEventListener("keydown", keyHandler, false);

        // Initializes prevTime.
        var prevTime = performance.now();

        // Animates the game.
        animate();
    </script>
    </body>    
</html> 